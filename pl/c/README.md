# C 语言


## 多文件项目

1. 将项目拆分成多个 `.c` 及 `.h` 文件，在 `.h` 中声明所有公共的方法、常量。
   1. `#include "filename"` 从当前文件夹开始寻找该头文件，如果本地找不到，再去系统的 lib 中找。
   2. `#include <filename>` 仅从系统的 lib 中寻找该头文件！
2. `static` 修饰的全局变量或者函数：仅在当前 `.c` 文件中可见，所有 `.c` 中的全局变量或者函数，都应该使用 `static` 修饰。
   1. `static` 也可用于局部变量，但是这种用法感觉不太常见。它为 function 提供了一个私有的、永久性的存储，在函数的多次执行中，该变量可以持久地存在并被使用。
3. `auto` 关键字声明自动变量，所有的局部变量默认都是自动变量。
   1. `auto` 的含义即为，它们会在程序运行期间被自动地创建、自动地销毁。
4. `register` 寄存器变量
   1. 此声明用于告知编译器该变量将被频繁使用，建议把它保存在 CPU 寄存器中。但是编译器有权忽略该建议。

## 常用函数

1. 字符处理
   1. `strlen`
   2. `atoi`: ascii to int
   3. `<ctype.h>`: 提供了 `islower` `isdigit` 等几个字符判断函数，以及 `tolower` `toupper` 两个大小写转换函数。
   4. 非标准库字符处理函数（windows `<conio.h>`, Linux `<ncurses.h>` 需要安装 ncurses-dev）
1. 数学 `<math.h>`
   1. `sqrt` 

## 易错知识点摘要

1. 文件结束符 EOF 在 `<stdio.h>` 中定义，是一个不在 ASCII 定义中的整数，通常使用 `-1` 来表示它。
   1. 这导致必须使用 `int` 来存储一个字符，否则 EOF 这个特殊值会发生溢出！
2. `getchar()` 从 `stdin` 中读取一个字符，但它是一个行缓冲函数，如果读到文件末尾，在遇到 `\n` 或者 EOF 前会一直阻塞。
   1. `putchar(c)` 则相反，将 c 放入 `stdout` 中。
3. 函数的传参，所有的参数都是传值，将外部变量的值 copy 给形参。
   1. 因此要特别注意传指针的情况，防止误修改。
4. 溢出：C 语言最需要警惕的问题之一，包括输入溢出、数字溢出。
5. 常量后缀。使用它可避免未知的隐式类型转换。
   1. `1L`: long 类型
   2. `1u`: unsigned int
   3. `1ul` 或者 `1UL`: unsigned long
   4. 无后缀：double 双精度
   5. `1.0f` 或者 `1.0F`: float 单精度
   6. `1.0l` 或者 `1.0L`: long double 长双精度
6. 常量前缀。用于表示不同的进制
   1. `0b11` 或者 `0B11`: 二进制数 11
   2. `017`: 8 进制数 17
      1. 因为前缀 0 容易引起歧义，Python 强制使用前缀 `0o`，即使用 `0o7` 来表示 8 进制。
   3. `0x17` 或者 `0X17`: 16 进制数 17
7. 字符与字符串字面量
   1. `'x'` 表示字符 x，类型为 `char`
   2. `"x"` 表示字符串 `['x', '\0']`，类型为 `char []`
8. `const` 限定符与指针共同使用时要注意，`const` 仅限定指针本身不可变！指针指向的变量是不受限制的。
9.  强制自动类型转换的规则：把较窄的操作数转换为较宽的操作数（提升精度低的操作数）
   1.  坑：char 的符号之争。一般 signed 与 unsigned 的 char 使用上没啥区别，但是在类型转换时会涉及位拓展问题。
10. 无符号数：它很省空间，但是也非常危险，很容易搞出预期外的问题！
    1.  应该仅在这两种场景下使用无符号数：需要执行按位运算时、需要进行不寻常的算术操作时。
11. 对于 `n++++` 这类问题的讨论没有什么意义，C 语言并未规定它的结果，它的执行效果因环境而异，属于未定义行为！
    1. 绝对不能随意些这类代码！
12. 指针的算术运算
    1.  指针可以加减一个整数，并且此计算会自动考虑指针所指对象的长度，如 `p++` 代表移到指针所在内存的下一个对象（内存地址）上。
    2.  指针之间可以做减法运算，这表示两指针之间的数据长度。
    3.  指针上的其他运算都是非法的，因为这些计算的指都没有任何实际意义（如指针之和、指针上的乘除法）。
    4.  指针运算非常容易出错！一定要慎重使用！！


## 问题

### 浮点数在内存中是如何存储的？

将一个浮点数强制转换为整数类型，然后再用 16 进制打印出其内容，就能得到其存储表示：

```c
#include<stdio.h>

int main() {
    float a = 3.14;
    printf("float: %f\n", a);
    // &a 取指针，再将指针强转为 (int *) 类型，再取出指针所指向的值（int）
    printf("excat: %x\n", *(int *)&a);

    return 0;
}
```
