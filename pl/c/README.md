# C 语言

1. 文件结束符 EOF 在 `<stdio.h>` 中定义，是一个不在 ASCII 定义中的整数，通常使用 `-1` 来表示它。
   1. 这导致必须使用 `int` 来存储一个字符，否则 EOF 这个特殊值会发生溢出！
2. `getchar()` 从输入流中读取一个字符，但它是一个行缓冲函数，如果读到文件末尾，在遇到 `\n` 或者 EOF 前会一直阻塞。
   1. 对应的立即缓冲函数在 `<conio.h>` 中定义，适合用于游戏等要求无阻塞 IO 的场景。
   2. 还有一个对应的 `getch()` 函数，它的优势在于还存在一个对应的 `ungetch()`，可以将读过的数据再压回缓冲区。
3. 函数的传参，所有的参数都是传值，将外部变量的值 copy 给形参。
   1. 因此要特别注意传指针的情况，防止误修改。
4. 溢出：C 语言最需要警惕的问题之一，包括输入溢出、数字溢出。
5. 常量后缀。使用它可避免未知的隐式类型转换。
   1. `1L`: long 类型
   2. `1ul` 或者 `1UL`: unsigned long
   3. 无后缀：double 双精度
   4. `1.0f` 或者 `1.0F`: float 单精度
   5. `1.0l` 或者 `1.0L`: long double 长双精度
6. 常量前缀。用于表示不同的进制
   1. `0b11` 或者 `0B11`: 二进制数 11
   2. `017`: 8 进制数 17
      1. 因为前缀 0 容易引起歧义，Python 强制使用前缀 `0o`，即使用 `0o7` 来表示 8 进制。
   3. `0x17` 或者 `0X17`: 16 进制数 17
7. 字符与字符串字面量
   1. `'x'` 表示字符 x，类型为 `char`
   2. `"x"` 表示字符串 `['x', '\0']`，类型为 `char []`
8. `const` 限定符与指针共同使用时要注意，`const` 仅限定指针本身不可变！指针指向的变量是不受限制的。
9. 强制自动类型转换的规则：把较窄的操作数转换为较宽的操作数（提升精度低的操作数）
   1.  坑：char 的符号之争。一般 signed 与 unsigned 的 char 使用上没啥区别，但是在类型转换时会涉及位拓展问题。
10. 无符号数：它很省空间，但是也非常危险，很容易搞出预期外的问题！
    1.  应该仅在这两种场景下使用无符号数：需要执行按位运算时、需要进行不寻常的算术操作时。
11. 对于 `n++++` 这类问题的讨论没有什么意义，C 语言并未规定它的结果，它的执行效果因环境而异，属于未定义行为！
    1. 绝对不能随意些这类代码！
12. 指针的算术运算
    1.  指针可以加减一个整数，并且此计算会自动考虑指针所指对象的长度，如 `p++` 代表移到指针所在内存的下一个对象（内存地址）上。
    2.  指针之间可以做减法运算，这表示两指针之间的数据长度。
    3.  指针上的其他运算都是非法的，因为这些计算的指都没有任何实际意义（如指针之和、指针上的乘除法）。
    4.  指针运算非常容易出错！一定要慎重使用！！

