# 并发编程

Do not communicate by sharing memory; instead, share memory by communicating.

## goroutine 与 channel 通道


- 使用 `go` 命令可创建一个 goroutine，它类似一个单独的线程，独立于主 goroutine 执行
- 当 main goroutine 退出时，所有 goroutine 都将会被强制终止
- goroutines 通常使用 channel 互传数据
- channel block 可能会导致 goroutine leak，导致 OOM 内存耗尽或者程序死锁无法终止。
- 合理使用 buffered channel
- 注意并发安全问题，在循环中使用外部变量时，注意要先 copy，或者改成用 channel 接收参数
- 单向 channel，用于限制对 channel 的操作
- 应该总是由发送方关闭 channel，或者专门再设计一个观测者 goroutine 负责关闭 channel，避免 panic
- sync.WaitGroup 可用于实现观测者 goroutine 的功能，观测是否所有 channel 都已经结束。
- 通过 buffered channel 限制并发数量为 n，从而限制程序的资源用量，避免 fd 资源描述符用尽、CPU 跑满等问题。
  - 这被称为计数器信号量
  - 举例 `var tokens = make(chan struct{}, 20)`，channel 的值没有其他意义，一般直接使用 `struct{}` 或者 `bool`.
- 另一个限制并发数量的方法是，只创建 n 个 goroutines 作为 worker，然后 main goroutine 往 channel 里发数据，再由这几个 goroutines 处理。
- 可使用 select 同时等待多个 channel，其中最先就绪的 channel 对应的 case 将被处理，其他的 case 将被忽略。
  - `select {}` 将永远阻塞。
  - 如果多个 case 同时就绪，select 将通过随机算法从中随机选取一个 case 进行处理。
  - 带有 `default` 的 select 语句，可实现非阻塞通讯（no blocking）

使用 channel 的 close 方法实现「取消/完成」操作的广播机制：

```go
var done_ch = make(chan struct{})

func is_done() bool {
  select {
  case <- done_ch: // done_ch 被 close，或者 done_ch 中有元素被传递
    return true
  default:
    return true
  }
}

func mark_done(){
  close(done_ch)  // 关闭 channel，表示任务已结束
}
```

## 竞争条件 race condition

竞争条件是指一类特殊的并发编程 bug.

它指的是，当一项操作并非是原子的，那在并发执行时，可能会因为执行顺序混乱，而导致无法预测的、无意义的结果。
这个结果受编译器行为、指令执行顺序、底层机器架构等许多因素的影响，难以预测与复现，是非常棘手的一类 bug.

race condition 有如下几种类型：

- data race: 同时有多个线程并发访问同一个变量，并且其中有至少一个线程执行的是「写入」操作

这就是我们为什么需要时刻考虑并发安全问题的原因——为了避免 race condition.

## 并发安全

常用的 map 字典不是并发安全的，通常的解决办法有：

- 通过 channel 集中化处理对 map 的访问，使对 map 的写入操作串行化，其他 goroutine 只允许读不允许写
- 使用并发安全的字典 sync.Map，但是这会存在锁导致的性能消耗
- 手动使用 sync.Mutex 或 sync.RWMutex: 这是下策，通常性能是最差的

## sync 包

### 锁：sync.Mutex 与 sync.RWMutex

### 条件变量 sync.Cond

### 原子操作

### sync.Pool  临时对象池

### sync.Map 并发安全字典

