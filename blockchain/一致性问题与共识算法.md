# 一致性问题与共识算法

共识（Consensus）这个术语很多时候会与一致性（Consistency）术语放在一起讨论。严谨地讲，两者的含义并不完全相同。
一致性的含义比共识宽泛，在不同场景（基于事务的数据库、分布式系统等）下意义不同。具体到分布式系统场景下，一致性指的是多个副本对外呈现的状态。如前面提到的顺序一致性、线性一致性，描述了多节点对数据状态的共同维护能力。而共识，则特指在分布式系统中多个节点之间对某个事情（例如多个事务请求，先执行谁？）达成一致看法的过程。因此，达成某种共识并不意味着就保障了一致性。
实践中，要保障系统满足不同程度的一致性，往往需要通过共识算法来达成。
共识算法解决的是分布式系统对某个提案（Proposal），大部分节点达成一致意见的过程。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是主节点……等等。可以认为任何可以达成一致的信息都是一个提案。
对于分布式系统来讲，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。因此，系统中多个节点最关键的是对多个事件的顺序进行共识，即排序。
注：计算机世界里采用的是典型的“多数人暴政”，足够简单、高效。

一般来说，我们将一致性分成三类：

- 强一致性：写操作完成后，任何后续访问都能读到更新后的值
  - 强一致性是一个模糊的概念，实际存在两种含义：
    - ACID 中的 C: 指**系统状态的一致性**，两阶段提交能提供此类一致性
    - CAP 中的 C: 指**数据访问的线性一致性**，或者叫原子一致性，Raft/Paxos 都能提供线性一致性
- 弱一致性：写操作完成后，系统不能保证后续访问都能读到更新后的值
- 最终一致性：保证如果对某个对象没有新的写操作了，最终所有的后续访问都能读到相同的、最近更新的值

常见共识算法列举如下：

|        | 拜占庭容错 | 一致性   | 性能 | 可用性（能容忍多大比例的节点出现故障） |
| ------ | ----- | ----- | -- | --- |
| 两阶段提交 2PC    | 否     | 强一致性  | 低  | 低   |
| TCC(try-confirm-cancel)    | 否     | 最终一致性 | 低  | 低   |
| Paxos  | 否     | 强一致性  | 中  | 中   |
| ZAB    | 否     | 最终一致性 | 中  | 中   |
| Raft   | 否     | 强一致性  | 中  | 中   |
| Gossip | 否     | 最终一致性 | 高  | 高   |
| Quorum NWR | 否     | 强一致性  | 中  | 中   |
| PBFT   | 是     | N/A   | 低  | 中   |
| PoW    | 是     | N/A   | 低  | 中   |
| PoS    | 是     | N/A   | 低  | 中   |
| [PoH](https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8)    | 是     | N/A   | 低  | 中   |


拜占庭错误是 1982 年兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了在少数节点不仅存在故障，还存在恶意行为的场景下，能否达成共识这样一个问题。而拜占庭容错则是指能否容忍拜占庭错误。
根据解决的场景是否允许拜占庭错误情况，共识算法可以分为 Crash Fault Tolerance (CFT) 和 Byzantine Fault Tolerance（BFT）两类。

对于非拜占庭错误的情况，已经存在不少经典的算法，包括 Paxos（1990 年）、Raft（2014 年）及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。
对于要能容忍拜占庭错误的情况，包括 PBFT（Practical Byzantine Fault Tolerance，1999 年）为代表的确定性系列算法、PoW（1999 年）为代表的概率算法等。确定性算法一旦达成共识就不可逆转，即共识是最终结果；而概率类算法的共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上结果。拜占庭类容错算法往往性能较差，容忍不超过 1/3 的故障节点。
此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。
Algorand 算法（2017 年）基于 PBFT 进行改进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好的性能（1000+ TPS）。
注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对结果，确保获取结果的准确性。

在不可信环境中，因为可能存在恶意行为，就需要使用支持拜占庭容错的共识算法如 Pow/PoS，这就是区块链为什么使用这两种算法的原因。

而在企业内网等场景下，可以认为是可信环境，不太可能出现恶意节点，这种场景下系统具有故障容错能力就够了，就没必要做到拜占庭容错，因此常用 Raft/Paxos 等算法。

参考：
- https://github.com/yeasy/blockchain_guide
- [区块链协议安全系列— —当拜占庭将军犯错时，区块链共识还安全么？（上集）](https://paper.seebug.org/1643/)


## 分布式锁

对锁的要求不是很高的场景（大部分普通微服务），通常使用基于 Redis 的分布式锁如 java 的 [redission](https://github.com/redisson/redisson)，它其实是存在锁失效的可能的，但是它性能够高，而且在很多场景下这种程度的一致性已经够用了，所以很受欢迎。

TBD

